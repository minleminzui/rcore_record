# 第二章
### 2.1.1算术指令
- 汇编指令的变量通过`寄存器`，为了电路设计简单，汇编语言不适用变量作为操作数，而是使用`寄存器`作为操作数![](./2.1.1.jpg)
- 使用`寄存器`的缺点是，寄存器数量有限。一般通过高效使用寄存器，或者编译器优化寄存器的使用，来提升效率
- R5有32个寄存器![](./2.1.1_register.jpg)
- R5的注释使用`#`![](./2.1.1comment.jpg)
- 为什么在R5中没有`立即数减法指令`?因为可以根据`立即数加法指令`实现,在精简指令集中，如果一个操作可以由其他操作实现，那么就可以不需要增加这个操作，精简指令集设计的操作类型越少越好
- 由于`立即数0`非常常用，所以寄存器`x0`被`硬连线`为0
### 2.2.1 访存指令
- 总结![](./2.2.1.jpg)
### 2.3.1 条件判断分支转移指令
- 总结![](./2.3.1.jpg)
### 2.4.1 逻辑运算指令
- 总结![](./2.4.1.jpg)
### 2.5.1 函数调用
- 符号寄存器
    -`a0~a7`表示参数寄存器`(x10~x17)`
    - `x0`一定是0
- `伪指令`表示一些汇编的`简写语法`，也就是说不存在对应的真实指令，而是说它是由真实机器指令组合而成
    - `mv rd, rs` 是指`addi rd, rs, 0`
    - `li rd 13`表示`addi rd, x0, 13 `
- 函数调用流程
    - ![](./2.5.1function_call1.jpg)
    - ![](./2.5.1function_call2.jpg)
- R5中函数调用的约定![](./2.5.1function_call_convention.jpg)
- 在`RISC-V`中所有的指令都是`4字节`
- `jal`指令是`jump 和 save return address`![](./2.5.1jal.jpg)
- 总结![](./2.5.1conclusion.jpg)
### 2.6.1 栈的使用
- `s0-s11`寄存器也就是`x8-x9,x19-x27`寄存器，一般会用来存放`局部变量和运算的中间结果值`，所以一般在函数调用前需要把它们存入栈中
- `递归调用`中，会把`a0-a7`以及`ra`中的值破坏，所以这个时候一般保存到栈中，这类寄存器就是`Caller`寄存器，可以理解为需要Caller保存的意思
- 类似于`a0-a7`这种寄存器和`ra`临时寄存器`t0-t6`这种寄存器一般可能会被Callee修改，所以`Caller`在调用函数之前，需要复制保存好它们![](./2.6.1caller.jpg)这里的ABI Name指的是在汇编代码中使用这个标识来指代这个寄存器
- 对于这个图中的栈中保存的值，为什么除了`s0-s11`寄存器，还有`local variables`呢?因为struct或者数组这种一般不会存在`s0-s11`寄存器种，所以临时struct或者数组也必须存到caller栈中![](./2.6.1stack1.jpg)![](./2.6.1stack2.jpg)
- 为什么需要两个`寄存器`存储返回值?![](./2.6.1conclusion.jpg)因为可能需要返回62位数，而这里的`a0,a1`都是32位的
### 3.1.1 R型指令
- 为了简洁性，在`RV32，RV64，RV128`,所有RV指令都是`固定32位`
- R5有6种指令![](./3.1.1_instruction.jpg)
- R-型指令![](./3.1.1_R_instruction.jpg),`opcode`标识R型指令的固定值，`funct7+funct3`是用来描述具体指令，其他域都是5位，因为寄存器有32个
### 3.2.1 I型指令和S型指令
- I型指令的`rs2`域和`fucnt3`域被替换位12位的`Imm[11:0]`,立即数会被符号扩展为`32`位![](./3.2.1I_instruction.jpg)
- S型指令指的是`Store`
### 3.3.1 B型指令和U型指令
- B型指令指的是`Branch`
- 由于`指令`存储在一个较为集中的区域，以及循环体一般不会太大(循环中也会用到Branch)，所以所以Branch跳转不会太大![](./3.3.1branch.jpg),所以branch使用`相对寻址PC-Relative Addressing`,并且`偏移量`的单位是`4bytes`,但是，R5的扩展指令存在`2字节`的扩展指令，所以偏移量单位只能是`2字节`
- 所有的`条件分支指令`都属于`并/必行指令？`
- U型指令是指`Upper Immediate`指令，装载高比特位立即数指令![](./3.3.1_upper.jpg)
    - `LUI`指令用来设置一个目的寄存器的高20位比特位, 并且可以将低12位清零，之后可以使用`ADDI`来设置目的寄存器的低12位
    - `AUIPC`![](./3.3.1_auipc.jpg)可以用来实现寄存器相对寻址
### 3.4.1 J型指令
- 对于LUI指令，一般来说ADDI的立即数都需要符号扩展![](./3.4.1LUI.jpg),所以可以通过提前给前20位加1，解决这个问题，在汇编中的伪指令`li`直接装入32位值，但是它在编译的时候还是会被编译成`lui和addi`两条指令![](./3.4.1J_instruction.jpg)
- J型指令(比如JAL)可以实现跳转,这里所说的branch指令减少硬件开销是指最低位默认为零吧？![](./3.4.1J_Branch.jpg)
- `JALR`指令![](./3.4.1_jalr.jpg),
    - `ret`就是`jr ra`,就是`jalr x0, ra, 0`![](./3.4.1auipc.jpg)
### 4.1.1 数据通路基本单元
- `数据通路可以理解为`，数据会经过的`路径`,数据通路一般有五个阶段![](./4.1.1_datapath.jpg)，一般`数据通路单元`包括`指令寄存器，数据存储器，寄存器堆，ALU和加法器`
- 这里所说的`两块存储器`，不就成了`哈佛结构`了?![](./4.1.1_mem.jpg)
### 4.2.1 R型指令和I型指令
- 每种类型指令的数据通路了都是不同的，比如R型数据通路![](./4.2.1R_DataPath.jpg)
